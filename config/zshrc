#
# ZSH config by Joakim Andersson
#
# Adapted from different sources on the Interblag.
# Mutated heavily over the years.
#

# Some options
setopt autolist                # List alternatives on tab completion
setopt autoremoveslash         # Remove '/' from completion
setopt braceccl                # Allow expressions like {a-zA-Z}
setopt correct                 # Try to correct spelling of commands
setopt extendedglob            # Use zsh extended globbing
setopt hashdirs                # Hash whole dir on exec
setopt hashlistall             # Hash all on first completion
setopt histignoredups          # No duplicates in history
setopt histreduceblanks        # History pretty printer
setopt listtypes               # Incl type in completion alternatives
setopt longlistjobs            # List jobs in long format
setopt nonomatch               # No errors for unmatched patterns
setopt completeinword          # Completion in the middle of word
setopt listpacked              # Variable col width for alternatives
setopt noclobber               # Don't overwrite files with >
setopt autopushd               # Make cd act like pushd
setopt pushdminus              # Invert order for 'cd -X/+X'
setopt pushdignoredups         # No duplicates on dirstack

# Preserve history
HISTSIZE=500
HISTFILE=~/.zsh_history
SAVEHIST=500

# Use and preserve directory stack
DIRSTACKSIZE=20
DIRSTACKFILE=~/.zdirs
if [[ -f $DIRSTACKFILE && $#dirstack -eq 0 ]]; then
    dirstack=( ${(f)"$(< $DIRSTACKFILE)"} )
    # Make 'cd -' go to exit dir of last shell
    if [[ -d $dirstack[1] && $dirstack[1] != $PWD ]]; then
        cd $dirstack[1] && cd $OLDPWD
    elif [[ $dirstack[1] == $PWD ]]; then
        # Exit dir of last shell is $PWD, pop to avoid duplicates
        popd > /dev/null
    fi
fi
TRAPEXIT() {
    [[ -e $DIRSTACKFILE ]] || touch $DIRSTACKFILE
    dirstack=( $PWD $dirstack )
    print -l ${(u)dirstack} >| $DIRSTACKFILE
}

# If $EDITOR begins with vi, ZSH goes into vi mode, and that's a bit too nerdy
bindkey -e

# Make Home, End and Delete work as expected
bindkey '\eOH' beginning-of-line
bindkey '\e[1~' beginning-of-line
bindkey '\e[H' beginning-of-line
bindkey '\eOF' end-of-line
bindkey '\e[4~' end-of-line
bindkey '\e[F' end-of-line
bindkey '\e[3~' delete-char

# Some handy aliases
alias ls="ls -F"
alias d='ls'
alias dl='ls -la'
alias l='ls'
alias ll='ls -l'
alias la='ls -la'
# I've made mistakes too many times...
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Enable color support of ls and grep
if [[ $TERM != dumb ]]; then
    ls_bin="ls"
    grep_bin="grep"
    if [[ -x =dircolors ]]; then
        # Support for systems where GNU ls is placed elsewhere
        if [[ -x =dirname ]]; then
            better_ls_bin="$(dirname =dircolors)/ls"
            if [[ -x "$better_ls_bin" ]]; then
                ls_bin="$better_ls_bin"
            fi
            unset better_ls_bin
        fi

        eval "$(dircolors -b ~/.dircolors)"

    # Fallback to default BSD names
    elif [[ -x =gdircolors && -x =gls ]]; then
        eval "$(gdircolors -b ~/.dircolors)"
        ls_bin="gls"
        [[ -x =ggrep ]] && grep_bin="ggrep"
    fi

    # Test if ls supports --color=auto
    if $ls_bin --color=auto >/dev/null 2>&1; then
        alias ls="$ls_bin -F --color=auto"
    else
        alias ls="$ls_bin -F"
    fi

    # Test if grep supports --color=auto
    if echo a | $grep_bin --color=auto a >/dev/null 2>&1; then
        alias grep="$grep_bin --color=auto"
    else
        alias grep="$grep_bin -F"
    fi

    unset ls_bin grep_bin
fi

# Set terminal title
case $TERM in
    (xterm*|*rxvt*)
#        preexec () { print -Pn "\e]0;%n@%m: $*\a" }
        precmd () { print -Pn "\e]0;%n@%m: %~\a" }
        ;;
    (screen)
        preexec () { echo -ne "\ek${1[(wr)^(*=*|sudo|-*)]}\e\\" }
        precmd () { echo -ne "\ekzsh\e\\" }
        ;;
esac

# Enable completion
zstyle ':completion:*' completer _expand _complete _correct _approximate
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle :compinstall filename '~/.zshrc'
autoload -Uz compinit
$(print -Pn "compinit -d $HOME/.zcompdump.%m")


# Set prompt
if [[ $TERM != dumb ]]; then
    fg_green=$'\e[01;32m'
    fg_red=$'\e[01;31m'
    fg_blue=$'\e[01;34m'
    fg_none=$'\e[00m'
fi
typeset -A prc
prc[promptchar]="%{%(?.$fg_green.$fg_red)%}%#%{$fg_none%}"
prc[userspec]="%{%(!.$fg_red.$fg_green)%}$USER@%m%{$fg_none%}"
export PROMPT="${prc[userspec]}:%{$fg_blue%}%~/${prc[promptchar]} "

# Load git prompt if possible
[[ -x =git && -f ~/.zshrc.git ]] && source ~/.zshrc.git

# System management aliases
if [[ -x =apt-get ]]; then
    alias ats='echo Searching... ; aptitude search'
    alias atv='aptitude show'
    alias acs='apt-cache search'
    alias acv='apt-cache show'
    alias acp='apt-cache policy'

    alias agu='sudo apt-get update'
    alias agug='sudo apt-get upgrade'
    alias agugd='sudo apt-get dist-upgrade'
    alias au='sudo apt-get update && sudo apt-get dist-upgrade'
    alias agi='sudo apt-get install'
    alias agir='sudo apt-get install --reinstall'
    alias agr='sudo apt-get remove'
    alias agrp='sudo apt-get remove --purge'
    alias agra='sudo apt-get autoremove'
    alias agrap='sudo apt-get autoremove --purge'

    alias di='sudo dpkg -i'
    alias drc='sudo dpkg-reconfigure'
    alias dlf='dpkg -L'
    alias agc='sudo apt-get autoclean'
    alias agtc='sudo apt-get clean'
fi
if [[ -f /var/log/syslog ]]; then
    sudo='sudo '
    [[ -r /var/log/syslog ]] && sudo=''
    alias syslog="${sudo}tail -F /var/log/syslog"
    unset sudo
fi

# Functions to update dotfiles and reload ZSH config
update_dotfiles() {
    local zshrc=$HOME/.zshrc
    local repo=${zshrc:A:h:h}
    zsh $repo/.update.zsh $@

    local estatus=$?
    if [[ $estatus -lt 2 ]]; then
        [[ $estatus == 0 ]] && reload_zshconfig
        return 0
    else
        return 1
    fi
}
reload_zshconfig() {
    source ~/.zshenv
    source ~/.zshrc
}

# Local overrides/additions
[[ -f ~/.zshrc.local ]] && source ~/.zshrc.local

# Clean up
unset prc

# Update and possibly reload config.
update_dotfiles auto
